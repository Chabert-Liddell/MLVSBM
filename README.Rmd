---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# MLVSBM

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/Chabert-Liddell/MLVSBM.svg?branch=master)](https://travis-ci.org/Chabert-Liddell/MLVSBM)
[![Codecov test coverage](https://codecov.io/gh/Chabert-Liddell/MLVSBM/branch/master/graph/badge.svg)](https://codecov.io/gh/Chabert-Liddell/MLVSBM?branch=master)
`r badge_devel("Chabert-Liddell\MLVSBM", "blue")`
<!-- badges: end -->

This is an implementation of a Stochastic Block Model for Multilevel Network (MLVSBM) 
as described in the following preprint: [https://arxiv.org/abs/1910.10512](https://arxiv.org/abs/1910.10512)

## Installation

You can install the released version of MLVSBM from [github](https://github.com) with:

```{r eval=FALSE}
devtools::install_github("Chabert-Liddell/MLVSBM")
```

## Tutorial

The package deals with multilevel network defined as the junction of two 
interaction network (adjacency matrices) linked by an affiliation relationship (affiliation matrix).

First, we're going to simulate a multilevel network with 100 individuals and 3 clusters of individuals for the lower level and  50 organizations and 3 clusters for the upper level.
The inter-organizational level will have an assortative structure  and will be undirected, the inter-individual's one a core-periphery structure and will be directed.
Affiliation matrix will be generated by a power law and the dependence between the 
stucture of the two levels will be strong.

```{r simulate}
set.seed(123)
my_mlvsbm <- MLVSBM::mlvsbm_simulate_network(
  n = list(I = 100, O = 50), # Number of nodes for the lower level and the upper level
  Q = list(I = 3, O = 3), # Number of blocks for the lower level and the upper level
  pi = c(.5, .3, .2), # Block proportion for the upper level, must sum to one
  gamma = matrix(c(.8, .1, .1,  # Block proportion for the lower level,
                   .1, .8, .1,
                   .1, .1, .8), # each column must sum to one
                 nrow = 3, ncol = 3, byrow = TRUE),  
  alpha = list(I = matrix(c(.1, .1, .3, 
                            .1, .2, .5,
                            .1, .5, .5), 
                          nrow = 3, ncol = 3, byrow = TRUE), # Connection matrix
               O = matrix(c(.5, .1, .1, 
                            .1, .5, .1,
                            .1, .1, .5), 
                          nrow = 3, ncol = 3, byrow = TRUE)),# between blocks
  directed = list(I = TRUE, O = FALSE), # Are the upper and lower level directed or not ?
  affiliation = "preferential", # How the affiliation matrix is generated
  no_empty_org = FALSE) # May the affiliation matrix have column suming to 0
```

The network is stocked in an R6 object of type MLVSBM.

Now, we are going to create a multilevel network object from 2 existing adjacency matrix 
and an affiliation matrix :
```{r create}
lower_level <- my_mlvsbm$adjacency_matrix$I # matrix of size nI x nI
upper_level <- my_mlvsbm$adjacency_matrix$O # matrix of size nO x nO
affiliation <- my_mlvsbm$affiliation_matrix # matrix of size nI x nO
my_mlvsbm2 <- MLVSBM::mlvsbm_create_network(X = list(I = lower_level, O = upper_level),
                                            A = affiliation)
```

We can now infer the parameters, blocks and edge probabilities of our network by
using the mlvlsbm_esimate_network function on an MLVSBM object. It will return the 
best model for this network as another R6 object of type FitMLVSBM. 
```{r infer}
fit <- MLVSBM:::mlvsbm_estimate_network(my_mlvsbm)
```


## Ploting the results

We can plot some synthetic view of the network :

```{r include=FALSE}
library(tidyverse)
library(blockmodels)
library(tidygraph)
library(ggforce)
library(ggraph)
library(cowplot)
```

Plotting adjacency matrices reordered by block with the link probability of each observed link.

```{r pressure, warning=FALSE,  dpi = 300}
ggdraw()+
  draw_plot(
    t(fit$X_hat$I * lower_level) %>% 
      as_tbl_graph() %>% 
      mutate(group = fit$Z$I) %>% 
      ggraph('matrix', sort.by = group)+
      geom_edge_point(aes(color = weight))+
      scale_edge_color_gradient(name = 'Prob', low = "#deebf7", high = "#08519c") +
      geom_hline(yintercept = cumsum(table(fit$Z$I))[-fit$nb_clusters$I]+.5) +
      geom_vline(xintercept = cumsum(table(fit$Z$I))[-fit$nb_clusters$I]+.5) +
      scale_y_reverse() +
      coord_fixed() +
      theme_graph() , 0, 0, .5, 1
  ) +
  draw_plot(
    t(fit$X_hat$O * upper_level) %>% 
      as_tbl_graph() %>% 
      ggraph('matrix', sort.by = fit$Z$O) +
      geom_edge_point(aes(color = weight)) +
      geom_hline(yintercept = cumsum(table(fit$Z$O))[-fit$nb_clusters$O]+.5) +
      geom_vline(xintercept = cumsum(table(fit$Z$O))[-fit$nb_clusters$O]+.5) +
      scale_edge_colour_gradient(name = 'Prob',low = "#fcbba1", high = "#67000d") +
      scale_y_reverse() +
      coord_fixed() + 
      theme_graph(), x = 0.5, y = 0, width = .5, height = 1  
    ) +
  draw_plot_label(label = c("Lower level", "Upper level"), x = c(0, .5), y = c(.9, .9))
```

To plot a synthetic view of the interaction between block and between the two levels :

```{r union_multilevel, dpi = 300}

tidy_clust_ind  <- tidygraph::as_tbl_graph(fit$parameters$alpha$I) %>% 
  mutate(name = seq(fit$nb_clusters$I)) %>% 
  mutate(A = fit$parameters$gamma[,1]) %>% 
  mutate(B = fit$parameters$gamma[,2]) %>% 
  mutate(C = fit$parameters$gamma[,3])
tidy_clust_org <- tidygraph::as_tbl_graph(fit$parameters$alpha$O) %>% 
  mutate(name = seq(fit$nb_clusters$O))

ind_layout <- create_layout(tidy_clust_ind, layout = "circle")
df_pie <- tibble::tibble(group = rep(seq(fit$nb_clusters$I), fit$nb_clusters$O),
                 x = rep(ind_layout$x, fit$nb_clusters$O),
                 y = rep(ind_layout$y, fit$nb_clusters$O),
                 amount = as.vector(table(list(fit$Z$I, 
                                               fit$affiliation_matrix %*% fit$Z$O))),
                 size = rep(as.integer(table(fit$Z$I)), fit$nb_clusters$O),
                 affiliation = rep(seq(fit$nb_clusters$O), each=fit$nb_clusters$I))
weight_ind <- as.vector(fit$parameters$alpha$I)
weight_org <- as.vector(fit$parameters$alpha$O)

p_clustind <- ggraph(ind_layout, width = weight, alpha = weight) +
  ggforce::geom_arc_bar(
    aes(x0 = x, y0 = y, r0 = 0.8*max(size)/length(fit$Z$I),r = 1*max(size)/length(fit$Z$I),
        fill = as.factor(affiliation), 
        amount = amount), stat = "pie", data = df_pie)+
  geom_edge_loop(aes(width = ( weight_ind > 0.05) * (weight_ind + 0.1)*.8, 
                     alpha = ( weight_ind > 0.05) * (weight_ind + 0.1) ))+
  geom_edge_fan(aes(
    start_cap = circle(radius = df_pie$size[node1.name]/length(fit$Z$I)*25, "mm"),
    end_cap = circle(radius = df_pie$size[node2.name]/length(fit$Z$I)*25, "mm"),
    alpha = ..index.., 
    width = (weight_ind>0.05)*(weight_ind+0.1)), 
    spread = 2)+
  geom_node_point(aes(stroke = .35*as.integer(table(fit$Z$I)), 
                      colour = as.factor(seq(fit$nb_clusters$I)))) +
  geom_node_text(aes(label = name)) +
  theme_graph(foreground = NA)+
  coord_equal()+
  scale_fill_brewer(palette = "YlOrRd", 
                    name = "Organisation", direction = -1) +
  scale_colour_brewer(palette = "Paired", name = "Individual") +
  scale_size_continuous(range = range(df_pie$size)/fit$nb_clusters$I)+
  scale_edge_alpha(range = c(0,1), guide = "none")+
  scale_edge_width(range = c(0, 3), guide = "none")+
  guides(size=FALSE, colour=FALSE, width=FALSE, fill = FALSE)


p_clustorg <- ggraph(tidy_clust_org, layout = "circle") +
  geom_edge_link(aes(
    alpha = (weight_org>0.05)*weight_org, 
    width = (weight_org>0.05)*weight_org)) +
  geom_edge_loop(aes(width = (weight_org>0.05)*(weight_org+0.1)*.8, 
                     alpha = (weight_org>0.05)*(weight_org+0.1) ))+
  geom_node_circle(aes(r = .5*as.integer(table(fit$Z$O))/length(fit$Z$O),
                     fill = as.factor(seq(fit$nb_clusters$O))))+
  geom_node_text(aes(label = name)) +
  theme_graph(foreground = NA)+
  coord_equal()+
  scale_fill_brewer(palette = "YlOrRd", name = "Organisation", direction = -1) +
  scale_colour_brewer(palette = "Paired", name = "Individual") +
  scale_edge_alpha(range = c(0,1), guide = "none")+
  scale_edge_width(range = c(1, 2), guide = "none")+
  guides(size=FALSE, colour=FALSE, width=FALSE, fill = FALSE)


ggdraw() +
  draw_plot(plot = p_clustind, x = 0, y = 0, width = .5, height = 1)+
  draw_plot(plot = p_clustorg, x = .5, y = 0, width = .5, height = 1)+
  draw_plot_label(label = c("Individuals", "Organisations"), x = c(0, 0.5))
```

## Some useful output
Output of the algorithm are stocked in the MLVSBM and FitMLVSBM objects.
The MLVSBM object stocks information of the observed or simulated network and a
list of all the fitted SBM and MLVSBM models.
```{r output_MLVSBM}
my_mlvsbm$ICL # A data frame of the inferred models 
my_fit <- my_mlvsbm$fittedmodels[[which.max(my_mlvsbm$ICL$ICL)]] # The fitted model with index  the highest ICL
my_mlvsbm$ICL_sbm # The ICL of the SBM
my_sbm_lower <- my_mlvsbm$fittedmodels_sbm$lower[[3]] # A fitted SBM for the lower level with 3 blocks
my_sbm_upper <- my_mlvsbm$fittedmodels_sbm$upper[[2]] # A fitted SBM for the upper level with 2 blocks
```

You can also get the parameters and the clustering of the fitted model from the
FitMLVSBM object as follows:
```{r output_Fit}
fit$parameters # The connectivity and membership parameters of the model
fit$Z # The membership of each nodes
fit$vbound # A vector of the varational bound of the VEM algorithm
tau <- fit$membership # The variational parameters of the model
pred <- fit$X_hat # The links predictions for each level
```
