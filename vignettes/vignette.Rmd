---
title: "vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MLVSBM)
```

The package deals with multilevel network defined as the junction of two 
interaction network (adjacency matrices) linked by an affiliation relationship (affiliation matrix).

First, we're going to simulate a multilevel network with 100 individuals and 3 clusters of individuals for the lower level and  50 organizations and 3 clusters for the upper level.
The inter-organizational level will have an assortative structure  and will be undirected, the inter-individual's one a core-periphery structure and will be directed.
Affiliation matrix will be generated by a power law and the dependence between the 
stucture of the two levels will be strong.

```{r simulate}
set.seed(123)
my_mlvsbm <- MLVSBM::mlvsbm_simulate_network(
  n = list(I = 60, O = 40), # Number of nodes for the lower level and the upper level
  Q = list(I = 3, O = 3), # Number of blocks for the lower level and the upper level
  pi = c(.5, .3, .2), # Block proportion for the upper level, must sum to one
  gamma = matrix(c(.8, .1, .1,  # Block proportion for the lower level,
                   .1, .8, .1,
                   .1, .1, .8), # each column must sum to one
                 nrow = 3, ncol = 3, byrow = TRUE),  
  alpha = list(I = matrix(c(.1, .1, .3, 
                            .1, .2, .5,
                            .1, .5, .5), 
                          nrow = 3, ncol = 3, byrow = TRUE), # Connection matrix
               O = matrix(c(.5, .1, .1, 
                            .1, .5, .1,
                            .1, .1, .5), 
                          nrow = 3, ncol = 3, byrow = TRUE)),# between blocks
  directed = list(I = TRUE, O = FALSE), # Are the upper and lower level directed or not ?
  affiliation = "preferential", # How the affiliation matrix is generated
  no_empty_org = FALSE) # May the affiliation matrix have column suming to 0
```

The network is stocked in an R6 object of type MLVSBM.

Now, we are going to create a multilevel network object from 2 existing adjacency matrix 
and an affiliation matrix :
```{r create}
lower_level <- my_mlvsbm$adjacency_matrix$I # matrix of size nI x nI
upper_level <- my_mlvsbm$adjacency_matrix$O # matrix of size nO x nO
affiliation <- my_mlvsbm$affiliation_matrix # matrix of size nI x nO
my_mlvsbm2 <- MLVSBM::mlvsbm_create_network(X = list(I = lower_level, O = upper_level),
                                            A = affiliation)
```

We can now infer the parameters, blocks and edge probabilities of our network by
using the mlvlsbm_esimate_network function on an MLVSBM object. It will return the 
best model for this network as another R6 object of type FitMLVSBM. 
```{r infer}
fit <- MLVSBM:::mlvsbm_estimate_network(my_mlvsbm, nb_cores = 1)
```

## Some useful output
Output of the algorithm are stocked in the MLVSBM and FitMLVSBM objects.
The MLVSBM object stocks information of the observed or simulated network and a
list of all the fitted SBM and MLVSBM models.
```{r output_MLVSBM}
my_mlvsbm$ICL # A data frame of the inferred models 
my_fit <- my_mlvsbm$fittedmodels[[which.max(my_mlvsbm$ICL$ICL)]] # The fitted model with index  the highest ICL
my_mlvsbm$ICL_sbm # The ICL of the SBM
my_sbm_lower <- my_mlvsbm$fittedmodels_sbm$lower[[3]] # A fitted SBM for the lower level with 3 blocks
my_sbm_upper <- my_mlvsbm$fittedmodels_sbm$upper[[2]] # A fitted SBM for the upper level with 2 blocks
```

You can also get the parameters and the clustering of the fitted model from the
FitMLVSBM object as follows:
```{r output_Fit}
fit$parameters # The connectivity and membership parameters of the model
fit$Z # The membership of each nodes
fit$vbound # A vector of the varational bound of the VEM algorithm
tau <- fit$membership # The variational parameters of the model
pred <- fit$X_hat # The links predictions for each level
```
