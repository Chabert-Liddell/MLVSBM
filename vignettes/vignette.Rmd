---
title: "vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MLVSBM)
```

The package deals with multilevel network defined as the junction of two 
interaction network (adjacency matrices) linked by an affiliation relationship (affiliation matrix).

First, we're going to simulate a multilevel network with 100 individuals and 3 clusters of individuals for the lower level and  50 organizations and 3 clusters for the upper level.
The inter-organizational level will have an assortative structure  and will be undirected, the inter-individual's one a core-periphery structure and will be directed.
Affiliation matrix will be generated by a power law and the dependence between the 
stucture of the two levels will be strong.

```{r simulate}
set.seed(123)
my_mlvsbm <- MLVSBM::mlvsbm_simulate_network(
  n = list(I = 60, O = 40), # Number of nodes for the lower level and the upper level
  Q = list(I = 3, O = 3), # Number of blocks for the lower level and the upper level
  pi = c(.5, .3, .2), # Block proportion for the upper level, must sum to one
  gamma = matrix(c(.8, .1, .1,  # Block proportion for the lower level,
                   .1, .8, .1,
                   .1, .1, .8), # each column must sum to one
                 nrow = 3, ncol = 3, byrow = TRUE),  
  alpha = list(I = matrix(c(.1, .1, .3, 
                            .1, .2, .5,
                            .1, .5, .5), 
                          nrow = 3, ncol = 3, byrow = TRUE), # Connection matrix
               O = matrix(c(.5, .1, .1, 
                            .1, .5, .1,
                            .1, .1, .5), 
                          nrow = 3, ncol = 3, byrow = TRUE)),# between blocks
  directed = list(I = TRUE, O = FALSE), # Are the upper and lower level directed or not ?
  affiliation = "preferential", # How the affiliation matrix is generated
  no_empty_org = FALSE) # May the affiliation matrix have column suming to 0
```

The network is stocked in an R6 object of type MLVSBM.

Now, we are going to create a multilevel network object from 2 existing adjacency matrix 
and an affiliation matrix :
```{r create}
lower_level <- my_mlvsbm$adjacency_matrix$I # matrix of size nI x nI
upper_level <- my_mlvsbm$adjacency_matrix$O # matrix of size nO x nO
affiliation <- my_mlvsbm$affiliation_matrix # matrix of size nI x nO
my_mlvsbm2 <- MLVSBM::mlvsbm_create_network(X = list(I = lower_level, O = upper_level),
                                            A = affiliation)
```

We can now infer the parameters, blocks and edge probabilities of our network by
using the mlvlsbm_esimate_network function on an MLVSBM object. It will return the 
best model for this network as another R6 object of type FitMLVSBM. 
```{r infer}
fit <- MLVSBM:::mlvsbm_estimate_network(my_mlvsbm, nb_cores = 1)
```

```{r eval=FALSE, echo=FALSE, include=FALSE}
graph_ind <- fit$adjacency_matrix$I %>%
  as_tbl_graph() %>%
  mutate(name = paste0("I", seq(nrow(fit$adjacency_matrix$I))),
         actor = "Individual",
         in_deg = colSums(fit$adjacency_matrix$I)) %>%
  activate(edges) %>% mutate(link = "Individual",
                             directed = fit$directed$I)
graph_org <- fit$adjacency_matrix$O %>%
  as_tbl_graph() %>%
  mutate(name = paste0("O", seq(nrow(fit$adjacency_matrix$O))),
         actor = "Organization",
         in_deg = colSums(fit$adjacency_matrix$O)) %>%
  activate(edges) %>% mutate(link = "Organization",
                             directed = fit$directed$O)
graph_aff <- fit$affiliation_matrix %>%
  as_tbl_graph() %>%
  mutate(name = c(paste0("I", seq(nrow(fit$adjacency_matrix$I))),
                  paste0("O", seq(nrow(fit$adjacency_matrix$O))))) %>% 
  activate(edges) %>% 
  mutate(link = "Affiliation", 
         directed = FALSE) 

lay_ind <- graph_ind %>% create_layout(layout = "stress")
lay_org <- graph_org %>% create_layout(layout = "stress")
lay_ind$x <- 8*(lay_ind$x - min(lay_ind$x))/max(lay_ind$x- min(lay_ind$x)) 
lay_ind$y <- 4*(lay_ind$y - min(lay_ind$y))/max(lay_ind$y- min(lay_ind$y)) 
lay_org$x <- 8*(lay_org$x - min(lay_org$x))/max(lay_org$x- min(lay_org$x)) +2
lay_org$y <- 4*(lay_org$y - min(lay_org$y))/max(lay_org$y- min(lay_org$y)) + 6 

graph_mlv <- graph_ind %>% bind_graphs(graph_org) %>%
  graph_join(graph_aff) 

pal_ind <- colorRampPalette(RColorBrewer::brewer.pal(max(3,max(fit$Z$I)), "GnBu"))
pal_org <- colorRampPalette(RColorBrewer::brewer.pal(max(3, max(fit$Z$O)), "YlOrRd"))

p <- graph_mlv %>%
  ggraph(layout = "manual", x = c(lay_ind$x, lay_org$x), y = c(lay_ind$y, lay_org$y)) +
  ggforce::geom_mark_rect(aes(x = x, y = y, group = actor, label = actor),
                          radius = 0) +
  # ggforce::geom_mark_ellipse(aes(x = x, y = y, filter = (as.factor(c(fit$Z$I, fit$Z$O + max(fit$Z$I))) == 2),
  #                                group = as.factor(c(fit$Z$I, fit$Z$O + max(fit$Z$I))),
  #                                fill = as.factor(c(fit$Z$I, fit$Z$O + max(fit$Z$I))))) +
  # annotate(geom = "segment", x = c(0, 0), y = c(-1, -1), xend = c(-1, 9), yend = c(4, 0)) +
  # annotate(geom = "segment", x = c(2, 2), y = c(5, 5), xend = c(1, 11), yend = c(10, 6)) +
  # annotate(geom = "text", x = c(8, 10), y = c(-.5, 5.5), label = c("Individuals", "Organizations"), angle = 45*1/9) +
  geom_edge_fan( aes(filter = (link != "Affiliation" & directed == TRUE) , 
                     alpha = .2*..index..),
                 width = .2) +
  geom_edge_link0(aes(filter = (link != "Affiliation" & directed == FALSE)),
                  width = .3, alpha = .2) +
  geom_edge_link0(aes(filter = (link == "Affiliation")), linetype = "dashed",
                  width = .3, alpha = .2) +
  geom_node_point(aes(filter = (actor == "Organization"), shape = actor, 
                      fill = as.factor(c(fit$Z$I, fit$Z$O + max(fit$Z$I))), 
                      size = in_deg), alpha = 1) +
  geom_node_point(aes(filter = (actor == "Individual"), shape = actor, 
                      fill = as.factor(c(fit$Z$I, fit$Z$O)), 
                      col = as.factor(c(as.vector(fit$affiliation_matrix %*% fit$Z$O),
                                        fit$Z$O)), size = in_deg), alpha = 1, stroke = 2) +
  # ggrepel::geom_text_repel(data = bind_rows(lay_ind, lay_org) %>% filter(in_deg > 10),
  #                          aes(x = x, y = y, label = name), size = 6) +
  scale_shape_manual(values = c(21, 22)) +
  scale_color_manual(values = pal_org(max(fit$Z$O))) +
  scale_fill_manual(values = c(pal_ind(max(fit$Z$I)), pal_org(max(fit$Z$O)))) +
  theme_graph() +
  theme(legend.position = "none")


ggsave(filename = "~/Pictures/multilevel.png", plot = p)
```



## Some useful output
Output of the algorithm are stocked in the MLVSBM and FitMLVSBM objects.
The MLVSBM object stocks information of the observed or simulated network and a
list of all the fitted SBM and MLVSBM models.
```{r output_MLVSBM}
my_mlvsbm$ICL # A data frame of the inferred models 
my_fit <- my_mlvsbm$fittedmodels[[which.max(my_mlvsbm$ICL$ICL)]] # The fitted model with index  the highest ICL
my_mlvsbm$ICL_sbm # The ICL of the SBM
my_sbm_lower <- my_mlvsbm$fittedmodels_sbm$lower[[3]] # A fitted SBM for the lower level with 3 blocks
my_sbm_upper <- my_mlvsbm$fittedmodels_sbm$upper[[2]] # A fitted SBM for the upper level with 2 blocks
```

You can also get the parameters and the clustering of the fitted model from the
FitMLVSBM object as follows:
```{r output_Fit}
fit$parameters # The connectivity and membership parameters of the model
fit$Z # The membership of each nodes
fit$vbound # A vector of the varational bound of the VEM algorithm
tau <- fit$membership # The variational parameters of the model
pred <- fit$X_hat # The links predictions for each level
```
